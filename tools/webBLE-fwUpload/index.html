<button id="connect">Connect with the BLE device</button>
<input id="fileItem" type="file" disable>
<button id="update" disable>Update FW</button>

<script>
const deviceName = 'UNISENSE';
const dfuService = '34c2e3b8-34aa-11eb-adc1-0242ac120002';
const dfuAckCharacteristic = '34c2e3be-34aa-11eb-adc1-0242ac120002';
const dfuInternalCharacteristic = '34c2e3b9-34aa-11eb-adc1-0242ac120002';

var bleDevice;
var gattService;
var gattAckCharacteristic;
var gattInternalCharacteristic;

var arrayFW;
var fwLen;
var bytesArray = new Uint8Array(67);
var iterations = 0;
var spareBytes = 0;
var updateIndex = 0;
//var dfuTimeout;
var debug = false;
var crc8bit = 0;
var onlyCRCleft = false;

document.querySelector('#connect').addEventListener('click', function() {
  if (isWebBluetoothEnabled()) { connect(); }
});

document.querySelector('#fileItem').addEventListener('change', function() {
  var reader = new FileReader();
  reader.onload = function() {
    var arrayBuffer = this.result;
    arrayFW = new Uint8Array(arrayBuffer);
    fwLen = arrayFW.length;

    console.log("Update fw length: ", fwLen);
    console.log(arrayFW);
    console.log("Computing 8-bit CRC...");
    crc8();
    console.log(crc8bit);
    console.log('Press "Update FW" button to start a fw update');

    document.querySelector('#update').disabled = false;
  }
  reader.readAsArrayBuffer(this.files[0]);
}, false);

document.querySelector('#update').addEventListener('click', function() {
  if (isWebBluetoothEnabled()) { 
    iterations = Math.floor(fwLen/64);
    spareBytes = fwLen%64;
    iterations++;
    if (debug == true) {
      console.log("Iterations: ", iterations);
      console.log("Spare bytes: ", spareBytes);
    }
    if (spareBytes == 0) {
      console.log("No remaining bytes in last packet to write CRC.");
      console.log("CRC will be sent alone in a new packet");
      onlyCRCleft = true;
    }
    updateIndex = 0;
    update(updateIndex);
  }
});

function isWebBluetoothEnabled() {
  if (!navigator.bluetooth) {
    console.log('Web Bluetooth is NOT available!');
    return false;
  }
  console.log('Web Bluetooth is available!');
  return true;
}

function getDeviceInfo() {
  let options = {
    filters: [{ name: deviceName}],
    optionalServices: [dfuService]
  };
  console.log('Requesting BLE device info...');
  return navigator.bluetooth.requestDevice(options).then(device => {
    bleDevice = device;
  }).catch(error => {
    console.log('Request device error: ' + error);
  });
}

function crc8() {
  var i;
  for (i = 0; i < fwLen; i++) {
    b = arrayFW[i];
    crc8bit = crc8bit ^ b;
  } 
}

function connect() {
  return getDeviceInfo()
  .then(connectGATTdfu)
  .then(connectGATTack)
  .then(_ => { console.log('Choose file') })
  .catch(error => { console.log('ERROR: ' + error); });
}

function connectGATTdfu() {
  console.log('Connecting to BLE device...')
  return bleDevice.gatt.connect()
  .then(server => {
    console.log("Getting server:", server);
    return server.getPrimaryService(dfuService);
  })
  .then(service => {
    gattService = service;
    console.log("Getting service:", service);
    return service.getCharacteristic(dfuInternalCharacteristic);
  })
  .then(characteristic => {
    console.log("Looking for characteristic...");
    gattInternalCharacteristic = characteristic;
    console.log("gattInternalCharacteristic:", gattInternalCharacteristic);
  });
}

function connectGATTack() {
  return gattService.getCharacteristic(dfuAckCharacteristic)
  .then(characteristic => {
    gattAckCharacteristic = characteristic;
    console.log("gattAckCharacteristic:", gattAckCharacteristic);
    //gattAckCharacteristic.addEventListener('characteristicvaluechanged', handleAckEvent)
    //gattAckCharacteristic.startNotifications();
  })
}


function readAck() {
  if (debug == true) {
    console.log('Reading Ack/Nack...');
  }
  gattAckCharacteristic.readValue()
  .then(value => {
    var ack = value.getUint8(0);
    if (debug == true) {
      console.log('AckVal is: ', ack);
    }
    handleAck(ack);
  });
}

function handleAck(value) {
  if (debug == true) {
    console.log('Value is '+ value);
  }
  if (value == 15) {
    if (debug == true) {
      console.log('Ack received!');
    }
    updateIndex++;
  } else {
    console.log('Nack received! Resend same packet');
  }
  if (updateIndex == iterations) {
    console.log('firmware sent');
    return;
  }
  update(updateIndex);
  //setTimeout(_ => {update(updateIndex);}, 1);
}

function handleAckEvent(event) {
  //clearTimeout(dfuTimeout);
  let value = event.target.value.getUint8(0);
  handleAck(value);
}

function update(index) {
  //clearTimeout(dfuTimeout);
  if (debug == true) {
    console.log(index);
  }

  filePtr = 64 * index;
  if (index == iterations - 1) {
    //Last byte
    bytesArray[0] = 1;
    bytesleft = spareBytes + 1; //add CRC to the count
    if (debug == true) {
      console.log("Packaging last byte with CRC");
      console.log("Total bytes left: ", bytesleft);
    }
    spare = new Uint8Array([
              (bytesleft & 0x00ff),
              (bytesleft & 0xff00) >> 8 ]);
    bytesArray.set(spare, 1);

    if (!onlyCRCleft) {
      bytesArray.set(arrayFW.slice(filePtr, (filePtr + spareBytes)), 3);
    }

    crc = new Uint8Array([
              (crc8bit & 0xff00) >> 8,
              (crc8bit & 0x00ff) ]);

    if (debug == true) {
      console.log("crc[0]: ", crc[0]);
      console.log("crc[1]: ", crc[1]);
    }

    //write CRC after the spare bytes
    bytesArray[3 + spareBytes] = crc[1];

    //Fill with 0s the remaining buffer
    lastBytes = new Uint8Array(64 - spareBytes - 1).fill(0);
    bytesArray.set(lastBytes, 3 + spareBytes + 1);

  } else {
    index_byte = new Uint8Array([
              (index & 0x00ff),
              (index & 0xff00) >> 8 ]);

    bytesArray[0] = 0;
    bytesArray.set(index_byte, 1);
    bytesArray.set(arrayFW.slice(filePtr, (filePtr + 64)), 3);
  }
  //console.hex(bytesArray);
  //console.log('Writing 67 bytes array...');
  gattInternalCharacteristic.writeValue(bytesArray)
  .then(_ => {  
    //dfuTimeout = setTimeout(handleTimeout, 1000); 
    setTimeout(readAck, 1);
    if (debug == true) {
      console.log('Written');
    }
  });
}

function handleTimeout() {
  console.log('Ack did not arrive in time');
  //updateIndex = 0;
  update(updateIndex);
}

</script>